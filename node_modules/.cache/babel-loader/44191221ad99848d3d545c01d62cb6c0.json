{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { windowRef } from '../MockWindow';\nimport { Logger } from '../utils/Logger';\nimport { PeerManager } from '../managers/PeerManager';\nimport { TransportType } from '../types/transport/TransportType';\nimport { ExtensionMessageTarget } from '../types/ExtensionMessageTarget';\nimport { TransportStatus } from '../types/transport/TransportStatus';\nimport { Origin } from '../types/Origin';\nimport { PostMessageClient } from './clients/PostMessageClient';\nimport { Transport } from './Transport';\nconst logger = new Logger('PostMessageTransport');\nlet listeningForExtensions = false;\nlet extensionsPromise;\nlet extensions;\n\nconst addExtension = extension => {\n  if (!extensions) {\n    extensions = [];\n  }\n\n  if (!extensions.some(ext => ext.id === extension.id)) {\n    extensions.push(extension);\n    windowRef.postMessage('extensionsUpdated', windowRef.location.origin);\n  }\n};\n/**\n * @internalapi\n *\n *\n */\n\n\nexport class PostMessageTransport extends Transport {\n  constructor(name, keyPair, storage, storageKey) {\n    super(name, new PostMessageClient(name, keyPair), new PeerManager(storage, storageKey));\n    this.type = TransportType.POST_MESSAGE;\n  }\n\n  static isAvailable() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return new Promise(resolve => {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const fn = event => {\n          const data = event.data;\n\n          if (data && data.payload === 'pong') {\n            resolve(true);\n            windowRef.removeEventListener('message', fn);\n          }\n        };\n\n        windowRef.addEventListener('message', fn);\n        const message = {\n          target: ExtensionMessageTarget.EXTENSION,\n          payload: 'ping'\n        }; // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n        windowRef.postMessage(message, windowRef.location.origin);\n      });\n    });\n  }\n\n  static getAvailableExtensions() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (extensionsPromise) {\n        return extensionsPromise;\n      }\n\n      if (extensions) {\n        return extensions;\n      }\n\n      extensions = [];\n      extensionsPromise = new Promise(resolve => {\n        PostMessageTransport.listenForExtensions();\n        setTimeout(() => {\n          resolve(extensions !== null && extensions !== void 0 ? extensions : []);\n        }, 1000);\n      }).finally(() => {\n        extensionsPromise = undefined;\n      });\n      return extensionsPromise;\n    });\n  }\n\n  static listenForExtensions() {\n    if (listeningForExtensions) {\n      return;\n    } // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n    const fn = event => {\n      const data = event.data;\n      const sender = data.sender;\n\n      if (data && data.payload === 'pong' && sender) {\n        logger.log('getAvailableExtensions', `extension \"${sender.name}\" is available`, sender);\n        addExtension(sender);\n      }\n    };\n\n    windowRef.addEventListener('message', fn);\n    const message = {\n      target: ExtensionMessageTarget.EXTENSION,\n      payload: 'ping'\n    }; // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n    windowRef.postMessage(message, windowRef.location.origin);\n    listeningForExtensions = true;\n  }\n\n  connect() {\n    const _super = Object.create(null, {\n      connect: {\n        get: () => super.connect\n      }\n    });\n\n    return __awaiter(this, void 0, void 0, function* () {\n      logger.log('connect');\n\n      if (this._isConnected !== TransportStatus.NOT_CONNECTED) {\n        return;\n      }\n\n      this._isConnected = TransportStatus.CONNECTING;\n      const knownPeers = yield this.getPeers();\n\n      if (knownPeers.length > 0) {\n        logger.log('connect', `connecting to ${knownPeers.length} peers`);\n        const connectionPromises = knownPeers.map(peer => __awaiter(this, void 0, void 0, function* () {\n          return this.listen(peer.publicKey);\n        }));\n        Promise.all(connectionPromises).catch(error => logger.error('connect', error));\n      }\n\n      yield this.startOpenChannelListener();\n      yield _super.connect.call(this);\n    });\n  }\n\n  startOpenChannelListener() {\n    return __awaiter(this, void 0, void 0, function* () {//\n    });\n  }\n\n  getPairingRequestInfo() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.client.getPairingRequestInfo();\n    });\n  }\n\n  listen(publicKey) {\n    return __awaiter(this, void 0, void 0, function* () {\n      logger.log('listen', publicKey);\n      yield this.client.listenForEncryptedMessage(publicKey, (message, context) => {\n        const connectionContext = {\n          origin: Origin.EXTENSION,\n          id: context.id\n        };\n        this.notifyListeners(message, connectionContext).catch(error => {\n          throw error;\n        });\n      }).catch(error => {\n        throw error;\n      });\n    });\n  }\n\n}","map":{"version":3,"sources":["../../../src/transports/PostMessageTransport.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA,SAAS,SAAT,QAA0B,eAA1B;AACA,SAAS,MAAT,QAAuB,iBAAvB;AACA,SAAS,WAAT,QAA4B,yBAA5B;AAKA,SAAS,aAAT,QAA8B,kCAA9B;AAEA,SAAS,sBAAT,QAAuC,iCAAvC;AACA,SAAS,eAAT,QAAgC,oCAAhC;AAEA,SAAS,MAAT,QAAuB,iBAAvB;AAEA,SAAS,iBAAT,QAAkC,6BAAlC;AACA,SAAS,SAAT,QAA0B,aAA1B;AAEA,MAAM,MAAM,GAAG,IAAI,MAAJ,CAAW,sBAAX,CAAf;AAEA,IAAI,sBAAsB,GAAY,KAAtC;AACA,IAAI,iBAAJ;AACA,IAAI,UAAJ;;AAEA,MAAM,YAAY,GAAI,SAAD,IAA+B;AAClD,MAAI,CAAC,UAAL,EAAiB;AACf,IAAA,UAAU,GAAG,EAAb;AACD;;AAED,MAAI,CAAC,UAAU,CAAC,IAAX,CAAiB,GAAD,IAAS,GAAG,CAAC,EAAJ,KAAW,SAAS,CAAC,EAA9C,CAAL,EAAwD;AACtD,IAAA,UAAU,CAAC,IAAX,CAAgB,SAAhB;AACA,IAAA,SAAS,CAAC,WAAV,CAAsB,mBAAtB,EAA2C,SAAS,CAAC,QAAV,CAAmB,MAA9D;AACD;AACF,CATD;AAWA;;;;AAIG;;;AACH,OAAM,MAAO,oBAAP,SAKI,SALJ,CAKsC;AAG1C,EAAA,WAAA,CAAY,IAAZ,EAA0B,OAA1B,EAAmD,OAAnD,EAAqE,UAArE,EAAkF;AAChF,UAAM,IAAN,EAAY,IAAI,iBAAJ,CAAsB,IAAtB,EAA4B,OAA5B,CAAZ,EAAkD,IAAI,WAAJ,CAAmB,OAAnB,EAA4B,UAA5B,CAAlD;AAHc,SAAA,IAAA,GAAsB,aAAa,CAAC,YAApC;AAIf;;AAE8B,SAAX,WAAW,GAAA;;AAC7B,aAAO,IAAI,OAAJ,CAAa,OAAD,IAAY;AAC7B;AACA,cAAM,EAAE,GAAI,KAAD,IAAqB;AAC9B,gBAAM,IAAI,GAAG,KAAK,CAAC,IAAnB;;AACA,cAAI,IAAI,IAAI,IAAI,CAAC,OAAL,KAAiB,MAA7B,EAAqC;AACnC,YAAA,OAAO,CAAC,IAAD,CAAP;AACA,YAAA,SAAS,CAAC,mBAAV,CAA8B,SAA9B,EAAyC,EAAzC;AACD;AACF,SAND;;AAQA,QAAA,SAAS,CAAC,gBAAV,CAA2B,SAA3B,EAAsC,EAAtC;AAEA,cAAM,OAAO,GAA6B;AACxC,UAAA,MAAM,EAAE,sBAAsB,CAAC,SADS;AAExC,UAAA,OAAO,EAAE;AAF+B,SAA1C,CAZ6B,CAgB7B;;AACA,QAAA,SAAS,CAAC,WAAV,CAAsB,OAAtB,EAAsC,SAAS,CAAC,QAAV,CAAmB,MAAzD;AACD,OAlBM,CAAP;AAmBD,K;AAAA;;AAEyC,SAAtB,sBAAsB,GAAA;;AACxC,UAAI,iBAAJ,EAAuB;AACrB,eAAO,iBAAP;AACD;;AAED,UAAI,UAAJ,EAAgB;AACd,eAAO,UAAP;AACD;;AAED,MAAA,UAAU,GAAG,EAAb;AACA,MAAA,iBAAiB,GAAG,IAAI,OAAJ,CAA0B,OAAD,IAAY;AACvD,QAAA,oBAAoB,CAAC,mBAArB;AAEA,QAAA,UAAU,CAAC,MAAK;AACd,UAAA,OAAO,CAAC,UAAU,KAAA,IAAV,IAAA,UAAU,KAAA,KAAA,CAAV,GAAA,UAAA,GAAc,EAAf,CAAP;AACD,SAFS,EAEP,IAFO,CAAV;AAGD,OANmB,EAMjB,OANiB,CAMT,MAAK;AACd,QAAA,iBAAiB,GAAG,SAApB;AACD,OARmB,CAApB;AAUA,aAAO,iBAAP;AACD,K;AAAA;;AAEiC,SAAnB,mBAAmB,GAAA;AAChC,QAAI,sBAAJ,EAA4B;AAC1B;AACD,KAH+B,CAKhC;;;AACA,UAAM,EAAE,GAAI,KAAD,IAAqB;AAC9B,YAAM,IAAI,GAAG,KAAK,CAAC,IAAnB;AAIA,YAAM,MAAM,GAAG,IAAI,CAAC,MAApB;;AACA,UAAI,IAAI,IAAI,IAAI,CAAC,OAAL,KAAiB,MAAzB,IAAmC,MAAvC,EAA+C;AAC7C,QAAA,MAAM,CAAC,GAAP,CAAW,wBAAX,EAAqC,cAAc,MAAM,CAAC,IAAI,gBAA9D,EAAgF,MAAhF;AACA,QAAA,YAAY,CAAC,MAAD,CAAZ;AACD;AACF,KAVD;;AAYA,IAAA,SAAS,CAAC,gBAAV,CAA2B,SAA3B,EAAsC,EAAtC;AAEA,UAAM,OAAO,GAA6B;AACxC,MAAA,MAAM,EAAE,sBAAsB,CAAC,SADS;AAExC,MAAA,OAAO,EAAE;AAF+B,KAA1C,CApBgC,CAwBhC;;AACA,IAAA,SAAS,CAAC,WAAV,CAAsB,OAAtB,EAAsC,SAAS,CAAC,QAAV,CAAmB,MAAzD;AAEA,IAAA,sBAAsB,GAAG,IAAzB;AACD;;AAEY,EAAA,OAAO,GAAA;;;;;;;;AAClB,MAAA,MAAM,CAAC,GAAP,CAAW,SAAX;;AACA,UAAI,KAAK,YAAL,KAAsB,eAAe,CAAC,aAA1C,EAAyD;AACvD;AACD;;AAED,WAAK,YAAL,GAAoB,eAAe,CAAC,UAApC;AAEA,YAAM,UAAU,GAAG,MAAM,KAAK,QAAL,EAAzB;;AAEA,UAAI,UAAU,CAAC,MAAX,GAAoB,CAAxB,EAA2B;AACzB,QAAA,MAAM,CAAC,GAAP,CAAW,SAAX,EAAsB,iBAAiB,UAAU,CAAC,MAAM,QAAxD;AACA,cAAM,kBAAkB,GAAG,UAAU,CAAC,GAAX,CAAsB,IAAP,IAAe,SAAA,CAAA,IAAA,EAAA,KAAA,CAAA,EAAA,KAAA,CAAA,EAAA,aAAA;AAAC,iBAAA,KAAK,MAAL,CAAY,IAAI,CAAC,SAAjB,CAAA;AAA2B,SAA5B,CAA9B,CAA3B;AAEA,QAAA,OAAO,CAAC,GAAR,CAAY,kBAAZ,EAAgC,KAAhC,CAAuC,KAAD,IAAW,MAAM,CAAC,KAAP,CAAa,SAAb,EAAwB,KAAxB,CAAjD;AACD;;AAED,YAAM,KAAK,wBAAL,EAAN;AAEA,YAAM,MAAA,CAAM,OAAN,CAAa,IAAb,CAAa,IAAb,CAAN;AACD,K;AAAA;;AAEY,EAAA,wBAAwB,GAAA;yDACnC;AACD,K;AAAA;;AAEY,EAAA,qBAAqB,GAAA;;AAChC,aAAO,KAAK,MAAL,CAAY,qBAAZ,EAAP;AACD,K;AAAA;;AAEY,EAAA,MAAM,CAAC,SAAD,EAAkB;;AACnC,MAAA,MAAM,CAAC,GAAP,CAAW,QAAX,EAAqB,SAArB;AAEA,YAAM,KAAK,MAAL,CACH,yBADG,CACuB,SADvB,EACkC,CAAC,OAAD,EAAkB,OAAlB,KAAgD;AACpF,cAAM,iBAAiB,GAAsB;AAC3C,UAAA,MAAM,EAAE,MAAM,CAAC,SAD4B;AAE3C,UAAA,EAAE,EAAE,OAAO,CAAC;AAF+B,SAA7C;AAKA,aAAK,eAAL,CAAqB,OAArB,EAA8B,iBAA9B,EAAiD,KAAjD,CAAwD,KAAD,IAAU;AAC/D,gBAAM,KAAN;AACD,SAFD;AAGD,OAVG,EAWH,KAXG,CAWI,KAAD,IAAU;AACf,cAAM,KAAN;AACD,OAbG,CAAN;AAcD,K;AAAA;;AAjIyC","sourceRoot":"","sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { windowRef } from '../MockWindow';\nimport { Logger } from '../utils/Logger';\nimport { PeerManager } from '../managers/PeerManager';\nimport { TransportType } from '../types/transport/TransportType';\nimport { ExtensionMessageTarget } from '../types/ExtensionMessageTarget';\nimport { TransportStatus } from '../types/transport/TransportStatus';\nimport { Origin } from '../types/Origin';\nimport { PostMessageClient } from './clients/PostMessageClient';\nimport { Transport } from './Transport';\nconst logger = new Logger('PostMessageTransport');\nlet listeningForExtensions = false;\nlet extensionsPromise;\nlet extensions;\nconst addExtension = (extension) => {\n    if (!extensions) {\n        extensions = [];\n    }\n    if (!extensions.some((ext) => ext.id === extension.id)) {\n        extensions.push(extension);\n        windowRef.postMessage('extensionsUpdated', windowRef.location.origin);\n    }\n};\n/**\n * @internalapi\n *\n *\n */\nexport class PostMessageTransport extends Transport {\n    constructor(name, keyPair, storage, storageKey) {\n        super(name, new PostMessageClient(name, keyPair), new PeerManager(storage, storageKey));\n        this.type = TransportType.POST_MESSAGE;\n    }\n    static isAvailable() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return new Promise((resolve) => {\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                const fn = (event) => {\n                    const data = event.data;\n                    if (data && data.payload === 'pong') {\n                        resolve(true);\n                        windowRef.removeEventListener('message', fn);\n                    }\n                };\n                windowRef.addEventListener('message', fn);\n                const message = {\n                    target: ExtensionMessageTarget.EXTENSION,\n                    payload: 'ping'\n                };\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                windowRef.postMessage(message, windowRef.location.origin);\n            });\n        });\n    }\n    static getAvailableExtensions() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (extensionsPromise) {\n                return extensionsPromise;\n            }\n            if (extensions) {\n                return extensions;\n            }\n            extensions = [];\n            extensionsPromise = new Promise((resolve) => {\n                PostMessageTransport.listenForExtensions();\n                setTimeout(() => {\n                    resolve(extensions !== null && extensions !== void 0 ? extensions : []);\n                }, 1000);\n            }).finally(() => {\n                extensionsPromise = undefined;\n            });\n            return extensionsPromise;\n        });\n    }\n    static listenForExtensions() {\n        if (listeningForExtensions) {\n            return;\n        }\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const fn = (event) => {\n            const data = event.data;\n            const sender = data.sender;\n            if (data && data.payload === 'pong' && sender) {\n                logger.log('getAvailableExtensions', `extension \"${sender.name}\" is available`, sender);\n                addExtension(sender);\n            }\n        };\n        windowRef.addEventListener('message', fn);\n        const message = {\n            target: ExtensionMessageTarget.EXTENSION,\n            payload: 'ping'\n        };\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        windowRef.postMessage(message, windowRef.location.origin);\n        listeningForExtensions = true;\n    }\n    connect() {\n        const _super = Object.create(null, {\n            connect: { get: () => super.connect }\n        });\n        return __awaiter(this, void 0, void 0, function* () {\n            logger.log('connect');\n            if (this._isConnected !== TransportStatus.NOT_CONNECTED) {\n                return;\n            }\n            this._isConnected = TransportStatus.CONNECTING;\n            const knownPeers = yield this.getPeers();\n            if (knownPeers.length > 0) {\n                logger.log('connect', `connecting to ${knownPeers.length} peers`);\n                const connectionPromises = knownPeers.map((peer) => __awaiter(this, void 0, void 0, function* () { return this.listen(peer.publicKey); }));\n                Promise.all(connectionPromises).catch((error) => logger.error('connect', error));\n            }\n            yield this.startOpenChannelListener();\n            yield _super.connect.call(this);\n        });\n    }\n    startOpenChannelListener() {\n        return __awaiter(this, void 0, void 0, function* () {\n            //\n        });\n    }\n    getPairingRequestInfo() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.client.getPairingRequestInfo();\n        });\n    }\n    listen(publicKey) {\n        return __awaiter(this, void 0, void 0, function* () {\n            logger.log('listen', publicKey);\n            yield this.client\n                .listenForEncryptedMessage(publicKey, (message, context) => {\n                const connectionContext = {\n                    origin: Origin.EXTENSION,\n                    id: context.id\n                };\n                this.notifyListeners(message, connectionContext).catch((error) => {\n                    throw error;\n                });\n            })\n                .catch((error) => {\n                throw error;\n            });\n        });\n    }\n}\n//# sourceMappingURL=PostMessageTransport.js.map"]},"metadata":{},"sourceType":"module"}